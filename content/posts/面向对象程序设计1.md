---
title: 面向对象程序设计1
published: 2026-02-19T22:40:53+08:00
summary: "关于面向对象的语法规则"
cover:
  image: https://bucket-qjy.oss-cn-qingdao.aliyuncs.com/picture/202601300127015.png
tags: [opp]
categories: '现代c++'
draft: false
lang: ''
---

# 继承与多态核心知识点详解（基于 C++）

以下按照你提供的大纲，逐节拆解继承与多态的核心知识点，结合 C++ 语法和实际场景讲解，帮你彻底掌握核心逻辑。

## 15.1 继承概述

### 继承

- **核心定义**：继承是 C++ 实现**代码复用**和**构建类层次结构**的核心机制。将通用的属性、行为封装在「基类（父类）」中，「派生类（子类）」通过继承复用基类的成员（变量 / 函数），并可扩展独有的功能。
- **本质关系**：最常见的是「is-a」关系（如`Student` is a `Person`），派生类是基类的特殊化。
- **核心价值**：避免重复代码，降低维护成本，为多态奠定基础。

### 动态绑定

- **核心定义**：也叫「运行时绑定」，程序运行时才确定调用哪个版本的函数（而非编译期）。
- **关联场景**：仅针对「基类指针 / 引用调用虚函数」的场景，是多态的核心实现方式。
- **对比静态绑定**：静态绑定（编译期绑定）是默认行为（如普通函数、值类型调用函数），动态绑定是多态的关键。

## 15.2 定义基类与派生类

### 15.2.1 定义基类

#### 成员函数与继承

- 基类的**非特殊成员**（普通成员变量、成员函数）可被派生类继承；
- **特殊成员不被继承**：构造函数、析构函数、赋值运算符重载（`operator=`），派生类需自定义，但若基类有默认 / 拷贝构造，派生类可隐式调用；
- **虚函数是关键**：基类中声明为`virtual`的函数，是实现动态绑定的前提。

#### 访问控制与继承

基类成员的访问限定符（`public`/`protected`/`private`）决定派生类能否直接访问：



| 基类成员限定符 | 派生类能否直接访问 | 外部（如 main）能否访问 |
| :------------: | :----------------: | :---------------------: |
|     public     |         能         |           能            |
|   protected    |         能         |          不能           |
|    private     |        不能        |          不能           |

### 15.2.2 定义派生类

#### 派生类中的虚函数

- **重写（override）规则**：派生类重写基类虚函数时，**函数签名必须完全匹配**（返回值、参数列表、`const`/`volatile`修饰、引用限定符）；

  - 例外：「返回值协变」（基类返回`Base*`，派生类可返回`Derived*`；基类返回`Base&`，派生类可返回`Derived&`）；

  

- **C++11 增强**：推荐在派生类虚函数后加`override`关键字，编译期检查是否真的重写了基类虚函数（避免签名写错导致隐式新增函数）。

  

  

  

  ```c++
  class Base {
  public:
      virtual void show(int a) const { /* ... */ }
  };
  class Derived : public Base {
  public:
      void show(int a) const override { /* 正确重写 */ }
      // void show(double a) const override { /* 编译报错：签名不匹配 */ }
  };
  ```

  

#### 派生类对象及派生类向基类的类型转换

- **核心规则**：派生类对象可「切片」为基类对象（仅保留基类部分），基类指针 / 引用可**隐式指向 / 引用派生类对象**（多态的基础）；

  

  

  

  ```c++
  Base b;
  Derived d;
  Base* ptr = &d;   // 合法：基类指针指向派生类对象
  Base& ref = d;    // 合法：基类引用绑定派生类对象
  Base b2 = d;      // 合法：切片，b2仅保留d的基类部分
  ```

  

- **本质**：派生类对象包含基类子对象，因此基类指针 / 引用能安全指向派生类的基类部分。

#### 派生类构造函数

- **初始化规则**：派生类构造函数必须先初始化「基类部分」，再初始化自身成员；

- **语法格式**：通过「初始化列表」调用基类构造函数，若省略则调用基类默认构造（基类无默认构造则编译报错）；

  

  

  

  

  ```c++
  class Base {
  public:
      Base(int x) : num(x) {} // 自定义构造，无默认构造
      int num;
  };
  class Derived : public Base {
  public:
      // 必须在初始化列表调用Base(int)
      Derived(int x, int y) : Base(x), val(y) {} 
      int val;
  };
  ```

  

- **执行顺序**：构造时先调用基类构造 → 再调用派生类构造；析构时反之（派生类析构 → 基类析构）。

#### 派生类使用基类的成员

- **同名成员处理**：若派生类有与基类同名的成员（变量 / 函数），派生类会「隐藏」基类成员，需用`Base::`作用域解析符显式访问；

  

  ```c++
  class Base {
  public:
      int a = 10;
      void func() { cout << "Base::func" << endl; }
  };
  class Derived : public Base {
  public:
      int a = 20;
      void func() { cout << "Derived::func" << endl; }
      void test() {
          cout << a << endl;          // 20（派生类自身）
          cout << Base::a << endl;    // 10（显式访问基类）
          func();                     // Derived::func
          Base::func();               // Base::func
      }
  };
  ```

  

- **访问权限**：仅基类的`public`/`protected`成员可被派生类访问，`private`成员需通过基类的`public/protected`成员函数间接访问。

#### 继承与静态成员

- **核心特性**：静态成员属于「类」而非「对象」，因此基类的静态成员在整个继承层次中**只有一份拷贝**，派生类可直接访问（无需对象）；

  

  ```c++
  class Base {
  public:
      static int count;
      static void showCount() { cout << count << endl; }
  };
  int Base::count = 0; // 静态成员必须类外初始化
  
  class Derived : public Base {};
  
  int main() {
      Base::count++;    // count=1
      Derived::count++; // count=2（共享同一份）
      Derived d;
      d.showCount();    // 输出2
      return 0;
  }
  ```

  

#### 派生类的生命周期

- **创建阶段**：基类构造函数 → 派生类构造函数（先基后派）；
- **销毁阶段**：派生类析构函数 → 基类析构函数（先派后基）；
- **关键坑点**：若基类析构函数不是`virtual`，用基类指针删除派生类对象会导致「未定义行为」（仅析构基类部分，派生类部分内存泄漏）。

#### 被用作基类的类

- 任何普通类都可作为基类（除非被`final`修饰）；
- **最佳实践**：若类设计为基类，务必将析构函数声明为`virtual`（确保派生类析构被正确调用）。

#### 防止继承发生 - final

- **类级 final**：类名后加`final`，禁止该类被继承；

  

  

  ```c++
  class Base final { /* ... */ };
  class Derived : public Base { /* 编译报错：Base被final修饰 */ };
  ```

  

- **函数级 final**：虚函数后加`final`，禁止派生类重写该虚函数；

  

  ```c++
  class Base {
  public:
      virtual void func() final { /* ... */ }
  };
  class Derived : public Base {
  public:
      void func() override { /* 编译报错：func被final修饰 */ }
  };
  ```

  

### 15.2.3 类型转换与继承

#### 静态类型与动态类型

- **静态类型**：变量声明时的类型（编译期确定）；

- **动态类型**：变量实际指向的对象类型（运行期确定）；

  

  

  ```c++
  Base* ptr = new Derived();
  // 静态类型：Base*（声明时的类型）
  // 动态类型：Derived*（实际指向的对象类型）
  ```

  

- 动态绑定的核心：根据「动态类型」调用函数，而非静态类型。

#### 不存在从基类向派生类的隐式类型转换

- 基类指针 / 引用**不能直接隐式转为派生类**（基类对象可能不是派生类的实例）；

- 若需转换，需用显式类型转换：

  - `static_cast`：编译期检查，无运行时安全校验（风险高）；

  - `dynamic_cast`：运行时检查，仅对「多态类型（有虚函数）」有效，转换失败时：

    - 指针版：返回`nullptr`；
    - 引用版：抛出`bad_cast`异常；

    

  

  

  

  ```c++
  Base* b_ptr = new Base();
  // Derived* d_ptr = b_ptr; // 编译报错：无隐式转换
  Derived* d_ptr = dynamic_cast<Derived*>(b_ptr); // d_ptr = nullptr（转换失败）
  ```

  

#### 在对象之间不存在类型转换

- 基类对象和派生类对象之间**无隐式转换**（仅指针 / 引用支持派生→基类的隐式转换）；

  

  ```c++
  Base b;
  // Derived d = b; // 编译报错：对象无法隐式转换
  ```

  

- 派生类对象可「切片」为基类对象（值拷贝基类部分），但反向无法还原（丢失派生类独有数据）。

## 15.3 虚函数

### 虚函数解析时机

- **动态绑定（运行时解析）**：基类指针 / 引用调用虚函数时，根据动态类型解析；

- **静态绑定（编译期解析）**：以下场景即使是虚函数，也会静态绑定：

  1. 值类型对象调用虚函数（如`Base b; b.func();`）；
  2. 构造函数 / 析构函数中调用虚函数（此时派生类部分未构造 / 已销毁，只能调用当前类的版本）；
  3. 显式指定类作用域调用（如`ptr->Base::func();`）。

  

### 派生类中的虚函数（补充）

- 基类声明`virtual`后，派生类重写的函数自动为虚函数（无需重复写`virtual`，但推荐写以增强可读性）；
- 重写必须匹配函数签名（C++11 的`override`强制检查，避免笔误）。

### final 和 override（补充）

- `override`：仅用于派生类虚函数，验证是否重写基类虚函数（编译期报错，而非运行时问题）；
- `final`：禁止继承（类）或禁止重写（虚函数），是「设计约束」的显式表达。

### 虚函数与默认实参

- **核心坑点**：虚函数的默认实参是「静态绑定」的（用静态类型的默认值，而非动态类型）；

  

  

  

  ```c++
  class Base {
  public:
      virtual void func(int a = 1) { cout << a << endl; }
  };
  class Derived : public Base {
  public:
      void func(int a = 2) override { cout << a << endl; }
  };
  int main() {
      Base* ptr = new Derived();
      ptr->func(); // 输出1（用Base的默认实参，而非Derived的2）
      return 0;
  }
  ```

  

- **最佳实践**：虚函数尽量避免使用默认实参，若必须用，确保基类和派生类的默认值一致。

## 15.4 抽象基类

### 纯虚函数

- **定义**：虚函数后加`= 0`，表示纯虚函数（无函数体，或可写函数体但需类外实现）；

  

  

  ```c++
  class Base {
  public:
      virtual void func() = 0; // 纯虚函数
  };
  // 纯虚函数也可写实现（可选）
  void Base::func() { cout << "Base::func" << endl; }
  ```

  

- **特性**：包含纯虚函数的类是「抽象基类」，**不能实例化**（只能作为基类）；

- **目的**：强制派生类重写纯虚函数，定义「接口规范」（如`Shape`类的`draw()`纯虚函数，`Circle`/`Rectangle`必须实现）。

### 派生类构造函数值初始化它的直接基类

- 抽象基类作为「直接基类」时，派生类构造函数必须初始化基类部分（若基类有自定义构造函数）；

- 若基类无自定义构造，派生类构造函数会「值初始化」基类（内置类型初始化为 0，类类型调用默认构造）；

  

  

  

  ```c++
  class Base { // 抽象基类
  public:
      Base(int x) : num(x) {}
      virtual void func() = 0;
      int num;
  };
  class Derived : public Base {
  public:
      // 必须初始化直接基类Base
      Derived() : Base(0) {} 
      void func() override { /* 实现纯虚函数 */ }
  };
  ```

  

## 15.5 访问控制与继承

### 受保护的成员（protected）

- **访问范围**：类内可访问 + 派生类可访问 + 外部不可访问；

- **核心价值**：为派生类开放访问权限，同时屏蔽外部访问（比`private`灵活，比`public`安全）；

  

  

  ```c++
  class Base {
  protected:
      int x = 10; // 受保护成员
  };
  class Derived : public Base {
  public:
      void test() { x = 20; } // 合法：派生类可访问
  };
  int main() {
      Base b;
      // b.x = 30; // 非法：外部不可访问protected成员
      return 0;
  }
  ```

  

### 公有、私有和受保护继承

继承方式决定「基类成员在派生类中的访问权限」，核心规则如下：



| 继承方式  | 基类 public 成员 | 基类 protected 成员 | 基类 private 成员 |          语义          |
| :-------: | :--------------: | :-----------------: | :---------------: | :--------------------: |
|  public   |  派生类 public   |  派生类 protected   |     不可访问      |     is-a（是一种）     |
| protected | 派生类 protected |  派生类 protected   |     不可访问      | 仅派生类的派生类可访问 |
|  private  |  派生类 private  |   派生类 private    |     不可访问      |   has-a（包含一种）    |

**示例：public 继承（最常用）**







```c++
class Base {
public: int a;
protected: int b;
private: int c;
};
class Derived : public Base {
public:
    void test() {
        a = 1; // 合法（public→public）
        b = 2; // 合法（protected→protected）
        // c = 3; // 非法（private不可访问）
    }
};
int main() {
    Derived d;
    d.a = 10; // 合法（public）
    // d.b = 20; // 非法（protected）
    return 0;
}
```

### 友元与继承

- **核心规则**：友元关系「不可继承」，且「单向」；

  1. 基类的友元，不能访问派生类的私有 / 保护成员；
  2. 派生类的友元，不能访问基类的私有 / 保护成员；
  3. 友元函数 / 类仅对「当前类」生效，与继承无关。

  

  

  

  

  ```c++
  class Base {
  private: int x;
  friend void func(Base& b); // func是Base的友元
  };
  class Derived : public Base {
  private: int y;
  };
  void func(Base& b) {
      b.x = 10; // 合法：Base的友元
      // Derived d; d.y = 20; // 非法：func不是Derived的友元
  }
  ```

  

### 改变个别成员的可访问性

- **语法**：用`using`声明，修改基类成员在派生类中的访问权限；

- **场景**：比如 private 继承后，需开放某个基类成员的访问权限；

  

  

  ```c++
  class Base {
  public:
      void func1() {}
      void func2() {}
  };
  // private继承：Base的public→Derived的private
  class Derived : private Base {
  public:
      using Base::func1; // 将func1改为public
      // func2仍为private
  };
  int main() {
      Derived d;
      d.func1(); // 合法（public）
      // d.func2(); // 非法（private）
      return 0;
  }
  ```

  

## 核心总结

1. **继承**：核心是代码复用，通过`public/protected/private`控制访问，`final`禁止继承；
2. **虚函数**：动态绑定的核心，`override`确保重写正确，`final`禁止重写，默认实参是静态绑定；
3. **多态**：基类指针 / 引用指向派生类对象 + 虚函数动态绑定，是面向对象的核心特性；
4. **抽象基类**：纯虚函数定义接口，强制派生类实现，不能实例化；
5. **坑点**：基类析构必须虚、虚函数默认实参静态绑定、基类→派生类无隐式转换。

掌握这些知识点后，可通过「定义基类→派生类重写虚函数→基类指针调用派生类函数」的实操巩固，核心是理解「静态类型 / 动态类型」和「绑定时机」的区别。