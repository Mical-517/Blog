---
title: 委托与组合代替继承
published: 2026-02-25T09:35:56+08:00
summary: "使用更简单安全的委托组合复用代码"
cover:
  image: https://bucket-qjy.oss-cn-qingdao.aliyuncs.com/picture/202602011340604.png
tags: [opp]
categories: '现代c++'
draft: false
lang: ''
---

## 一、核心概念解析（附 C++ 代码示例）

### 1. 组合（Composition）：“有一个”（has-a）的关系

组合是最基础的代码复用和对象关系设计方式，核心是**一个类将另一个类的对象作为自己的成员变量**，整体对象完全掌控部分对象的生命周期（部分对象随整体创建而创建、销毁而销毁）。

#### 核心特征：

- 强依赖：部分对象不能脱离整体对象独立存在；
- 语义是 “包含”：比如 “汽车有发动机”“手机有电池”。

#### C++ 代码示例：



```c++
#include <iostream>
using namespace std;

// 部分类：发动机
class Engine {
public:
    void start() {
        cout << "发动机启动" << endl;
    }
    void stop() {
        cout << "发动机关闭" << endl;
    }
};

// 整体类：汽车（组合了Engine）
class Car {
private:
    Engine engine; // 组合：Car拥有一个Engine对象（成员变量）
public:
    void drive() {
        engine.start(); // 调用部分对象的方法
        cout << "汽车开始行驶" << endl;
    }
    void park() {
        engine.stop();
        cout << "汽车停车" << endl;
    }
};

int main() {
    Car myCar;
    myCar.drive(); // 输出：发动机启动 → 汽车开始行驶
    myCar.park();  // 输出：发动机关闭 → 汽车停车
    return 0;
}
```

**关键解释**：

- `Car`类中直接包含`Engine`对象作为成员，`myCar`创建时，其内部的`engine`对象会自动构造；`myCar`销毁时，`engine`也会自动析构。
- 组合的核心是 “持有并使用”，逻辑简单且耦合度低。

### 2. 委托（Delegation）：“让别人做”（let someone else do）的关系

委托是**组合的特殊形式**，核心是 “功能转发”：一个类（委托者）持有另一个类（被委托者）的对象（通常是指针 / 引用），并将自己的部分 / 全部功能委托给被委托者实现。

#### 核心特征：

- 基于组合：本质是通过组合持有被委托者的引用 / 指针；
- 关注点在 “功能转发”：委托者不自己实现逻辑，而是转发给被委托者；
- 灵活性更高：可动态更换被委托者（因为用指针 / 引用）。

#### C++ 代码示例（经典的 Pimpl 惯用法，委托的典型应用）：



```c++
#include <iostream>
#include <memory> // 智能指针
using namespace std;

// 前向声明：被委托者（实现类）
class WindowImpl;

// 委托者：窗口类（对外暴露接口）
class Window {
private:
    unique_ptr<WindowImpl> pImpl; // 组合：持有被委托者的指针（委托核心）
public:
    Window();
    ~Window(); // 智能指针自动析构，需声明析构函数（前向声明的类需可见）
    void draw() {
        pImpl->draw(); // 委托：将绘制逻辑转发给WindowImpl
    }
};

// 被委托者的具体实现
class WindowImpl {
public:
    void draw() {
        cout << "绘制窗口（Windows系统）" << endl;
    }
};

// 委托者的构造函数：创建被委托者对象
Window::Window() : pImpl(make_unique<WindowImpl>()) {}
Window::~Window() = default;

int main() {
    Window myWindow;
    myWindow.draw(); // 输出：绘制窗口（Windows系统）
    return 0;
}
```

**关键解释**：

- `Window`（委托者）不自己实现`draw()`，而是通过`pImpl`指针委托给`WindowImpl`（被委托者）；
- 优势：可动态替换`WindowImpl`（比如换成 Linux 版本的实现），且隐藏实现细节（Pimpl 惯用法的核心价值）。

### 3. 继承（Inheritance）：“是一个”（is-a）的关系

先简单回顾继承，因为 “多用组合少用继承” 是对比继承而言的：继承是**一个类（子类 / 派生类）继承另一个类（父类 / 基类）的属性和方法**，语义是 “子类是父类的一种”（比如 “轿车是一种汽车”）。

#### 简单示例：



```c++
class Car {
public:
    void run() { cout << "汽车行驶" << endl; }
};

class Sedan : public Car { // 继承：Sedan is a Car
public:
    void run() override { // 重写父类方法
        cout << "轿车高速行驶" << endl;
    }
};
```

------





## 二、为什么 “多用组合（含委托），少用继承”？

继承看似简单，但过度使用会导致代码耦合高、灵活性差，而组合（含委托）能规避这些问题，核心原因如下：

### 1. 继承是 “强耦合”，组合是 “弱耦合”

- 继承的问题：子类与父类紧密绑定，父类的任何修改（比如方法签名、内部逻辑）都可能导致子类崩溃（“脆弱的基类问题”）。比如父类新增一个虚函数，子类若未适配，可能引发意想不到的错误。
- 组合的优势：整体类只依赖部分类的**公共接口**，部分类的内部修改只要不改变接口，整体类完全不受影响。比如修改`Engine`的`start()`内部逻辑，`Car`的`drive()`无需任何改动。

### 2. 继承违背 “封装性”，组合保留封装

- 继承的问题：子类能访问父类的`protected`成员，破坏了父类的封装（父类的内部细节暴露给子类）。一旦父类的`protected`成员修改，所有子类都要调整。
- 组合的优势：整体类只能通过部分类的`public`接口访问其功能，无法触及内部细节，完全遵循封装原则。

### 3. 组合更灵活（支持动态替换，继承是静态的）

- 继承的问题：子类的父类在编译期就固定了，运行时无法更换。比如`Sedan`继承自`Car`，就永远只能是`Car`的子类，无法动态换成`ElectricCar`的逻辑。

- 组合（委托）的优势：通过指针 / 引用持有部分对象，运行时可动态替换。比如修改 Pimpl 示例，让`Window`在运行时切换 Windows/Linux 版本的`WindowImpl`：

  

  

  ```c++
  // 新增Linux版本的实现
  class LinuxWindowImpl {
  public:
      void draw() { cout << "绘制窗口（Linux系统）" << endl; }
  };
  
  // Window新增方法：动态更换被委托者
  void Window::setImpl(unique_ptr<WindowImpl> newImpl) {
      pImpl = move(newImpl);
  }
  
  // 运行时切换
  myWindow.setImpl(make_unique<LinuxWindowImpl>());
  myWindow.draw(); // 输出：绘制窗口（Linux系统）
  ```

  

### 4. 继承易导致 “类爆炸”，组合更简洁

- 继承的问题：若通过继承实现多维度扩展（比如 “汽车” 分 “燃油 / 电动” 和 “轿车 / SUV”），会产生大量子类（燃油轿车、燃油 SUV、电动轿车、电动 SUV…），即 “类爆炸”。

- 组合的优势：将不同维度的功能拆分为独立类，通过组合组合这些类，避免类爆炸。比如：

  

  

  ```c++
  // 动力类型（燃油/电动）
  class Power {
  public:
      virtual void supply() = 0;
  };
  class FuelPower : public Power { /* 燃油逻辑 */ };
  class ElectricPower : public Power { /* 电动逻辑 */ };
  
  // 车型（轿车/SUV）
  class CarType {
  public:
      virtual void shape() = 0;
  };
  class SedanType : public CarType { /* 轿车逻辑 */ };
  class SUVType : public CarType { /* SUV逻辑 */ };
  
  // 汽车：组合动力+车型，无需创建大量子类
  class Car {
  private:
      unique_ptr<Power> power;
      unique_ptr<CarType> type;
  public:
      Car(unique_ptr<Power> p, unique_ptr<CarType> t) : power(move(p)), type(move(t)) {}
      void run() {
          power->supply();
          type->shape();
          cout << "汽车行驶" << endl;
      }
  };
  
  // 灵活组合：电动SUV
  Car electricSUV(make_unique<ElectricPower>(), make_unique<SUVType>());
  ```

  

### 5. 继承的 “is-a” 语义容易被误用

继承的核心是 “is-a”，但很多时候开发者会为了复用代码而滥用继承，违背语义。比如：



```c++
// 错误示例：为了复用File的read()方法，让TextEditor继承File
// 但“文本编辑器是一个文件”的语义不成立！
class File { public: void read() {} };
class TextEditor : public File {};
```

而组合是 “has-a”，更符合实际语义：`TextEditor` **有一个** `File`对象，用于读写文件，这才是合理的设计。

------

## 三、委托、组合、继承的关系

1. **委托是组合的 “特例”**：委托基于组合（持有另一个类的对象），但核心目标是 “功能转发”，而普通组合的核心是 “包含并使用”；

2. **组合和继承都是代码复用的方式**：继承是 “白盒复用”（暴露父类内部），组合（含委托）是 “黑盒复用”（只依赖接口）；

3. **继承可与组合结合使用**：并非完全不用继承，而是 “优先用组合，必要时用继承”。比如：

   - 继承适合 “真正的 is-a 关系”（比如`Shape`基类，`Circle`/`Rectangle`子类）；
   - 组合适合 “has-a 关系”（比如`Circle`有一个`Point`对象表示圆心）；
   - 委托适合 “需要动态替换实现” 的场景（比如 Pimpl、策略模式）。

   

------

### 总结

1. **核心概念**：组合是 “has-a” 的包含关系，委托是组合的特例（功能转发），继承是 “is-a” 的从属关系；
2. **设计原则**：优先用组合 / 委托而非继承，核心原因是组合耦合低、封装性好、灵活性高，能避免继承的 “脆弱基类”“类爆炸” 等问题；
3. **使用场景**：继承仅用于 “真正的 is-a 语义”，组合用于 “has-a 语义”，委托用于 “需要动态替换实现” 的场景。



## ps:一点疑惑

灵活性更高：可动态更换被委托者（因为用指针 / 引用）。这是什么意思



### 一、先理解核心概念：“动态更换被委托者”

“动态更换被委托者” 的本质是：**程序运行过程中（而非编译时），可以替换掉委托者所持有的 “被委托对象”，让委托者的同一个接口，执行不同被委托者的逻辑**。

简单类比：你有一个遥控器（委托者），它通过 “指针 / 引用” 连接到不同的家电（被委托者）—— 运行时你可以把遥控器从电视切换到空调，遥控器按 “开机” 键时，执行的就是空调的开机逻辑，而非电视的。

而如果不用指针 / 引用，直接把 “家电” 嵌在遥控器里（普通组合），遥控器出厂就绑定了电视，永远只能控制电视，无法切换。

### 二、为什么指针 / 引用能支持 “动态更换”？

C++ 中，**直接的对象成员（普通组合）是 “编译期绑定”**，而**指针 / 引用可以实现 “运行期绑定”**（配合多态）：

1. 直接对象成员：编译时就确定了对象的类型和内存布局，对象的生命周期和所属类完全绑定，无法中途替换；
2. 指针 / 引用：编译时只确定 “指针 / 引用指向某个基类”，运行时可以指向该基类的任意派生类对象 —— 只要派生类遵循基类的接口，就能无缝替换。

### 三、代码示例：直观对比 “无法更换” 和 “可动态更换”

### 场景：一个 “支付工具” 类（委托者），委托不同的 “支付方式”（被委托者）完成支付

#### 1. 普通组合（直接对象成员）：无法动态更换被委托者



```c++
#include <iostream>
using namespace std;

// 被委托者1：微信支付
class WeChatPay {
public:
    void pay(int money) {
        cout << "微信支付：" << money << "元" << endl;
    }
};

// 委托者：支付工具（直接持有微信支付对象）
class PayTool {
private:
    WeChatPay payMethod; // 普通组合：直接对象成员，编译时绑定
public:
    void doPay(int money) {
        payMethod.pay(money); // 只能调用微信支付
    }
};

int main() {
    PayTool tool;
    tool.doPay(100); // 只能输出：微信支付：100元
    // 想换成支付宝支付？不可能！因为payMethod是WeChatPay类型，编译时就固定了
    return 0;
}
```

**问题**：`PayTool` 内部直接持有 `WeChatPay` 对象，一旦写死，运行时永远无法换成支付宝、银行卡等其他支付方式，除非修改 `PayTool` 的代码并重新编译。

#### 2. 委托（指针 + 多态）：可动态更换被委托者





```c++
#include <iostream>
#include <memory> // 智能指针，更安全
using namespace std;

// 第一步：定义被委托者的基类（统一接口）
class PayMethod {
public:
    virtual void pay(int money) = 0; // 纯虚函数：统一支付接口
    virtual ~PayMethod() = default; // 基类必须有虚析构
};

// 第二步：实现不同的被委托者（派生类）
class WeChatPay : public PayMethod {
public:
    void pay(int money) override {
        cout << "微信支付：" << money << "元" << endl;
    }
};

class AliPay : public PayMethod {
public:
    void pay(int money) override {
        cout << "支付宝支付：" << money << "元" << endl;
    }
};

class BankPay : public PayMethod {
public:
    void pay(int money) override {
        cout << "银行卡支付：" << money << "元" << endl;
    }
};

// 第三步：委托者（用基类指针持有被委托者）
class PayTool {
private:
    unique_ptr<PayMethod> payPtr; // 指针：指向PayMethod基类
public:
    // 构造时初始化被委托者
    PayTool(unique_ptr<PayMethod> ptr) : payPtr(move(ptr)) {}

    // 核心：提供更换被委托者的接口
    void changePayMethod(unique_ptr<PayMethod> newPtr) {
        payPtr = move(newPtr); // 运行时替换指针指向的对象
    }

    // 委托：调用被委托者的pay方法
    void doPay(int money) {
        if (payPtr) { // 避免空指针
            payPtr->pay(money);
        }
    }
};

int main() {
    // 1. 初始用微信支付
    PayTool tool(make_unique<WeChatPay>());
    tool.doPay(100); // 输出：微信支付：100元

    // 2. 运行时动态换成支付宝（无需修改PayTool代码）
    tool.changePayMethod(make_unique<AliPay>());
    tool.doPay(200); // 输出：支付宝支付：200元

    // 3. 再动态换成银行卡
    tool.changePayMethod(make_unique<BankPay>());
    tool.doPay(300); // 输出：银行卡支付：300元

    return 0;
}
```

**关键解释**：

- `PayTool` 持有的是 `PayMethod*`（智能指针），而非具体的 `WeChatPay`/`AliPay` 对象 —— 编译时只知道 “指向支付方式基类”，不知道具体是哪种支付方式；
- 运行时通过 `changePayMethod` 方法，只需把指针指向新的派生类对象（比如 `AliPay`），就能让 `doPay` 执行新的逻辑；
- 哪怕后续新增 `ApplePay` 等新支付方式，只需新增一个 `PayMethod` 的派生类，无需修改 `PayTool` 的任何代码，完全符合 “开闭原则”（对扩展开放，对修改关闭）。

### 四、为什么普通对象成员做不到？

普通对象成员（如 `WeChatPay payMethod;`）在编译时就会为其分配固定大小的内存，类型完全确定。比如 `WeChatPay` 和 `AliPay` 的内存布局、大小可能不同，无法中途替换 —— 就像你买了一个内置电视芯片的遥控器，芯片焊死在里面，永远没法换成空调芯片。

而指针 / 引用的大小是固定的（32 位系统 4 字节，64 位 8 字节），不管指向什么派生类对象，指针本身的大小和类型不变，只是指向的内存地址变了 —— 就像遥控器的 “接口” 是固定的，只需换对接的家电，不用换遥控器本身。

------

### 总结

1. **动态更换被委托者**：程序运行时替换委托者所持有的被委托对象，让同一个接口执行不同逻辑；
2. **指针 / 引用的核心作用**：解耦了委托者和具体被委托者的 “编译期绑定”，通过多态实现运行时的对象替换；
3. **对比差异**：普通组合（直接对象）是 “死绑定”，委托（指针 / 引用）是 “活绑定”，这也是委托灵活性远高于普通组合的关键。

## 理解接口有专门的文章（已写）

