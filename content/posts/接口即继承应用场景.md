---
title: 接口即继承应用场景
published: 2026-02-25T09:48:28+08:00
summary: "接口是继承的主要应用场景，其余继承都可以使用组合代替"
cover:
  image: https://bucket-qjy.oss-cn-qingdao.aliyuncs.com/picture/202601300127015.png
tags: [接口]
categories: '现代c++'
draft: false
lang: ''
---

## 一、先理解：生活中的 “接口”（类比，建立直观认知）

先抛开代码，看你每天接触的 “接口”，核心是 **“约定好的规则 / 标准”**，只关心 “能做什么”，不关心 “怎么做”：

- 🔌 **电源插座**：这是一个接口 —— 它约定了 “三孔 / 两孔的形状、电压 220V”，不管你插空调、手机充电器还是台灯（不同 “实现”），只要插头符合这个规则，就能通电；插座完全不用管 “插的是啥、内部怎么耗电”。
- 🖨️ **USB 接口**：这是一个接口 —— 它约定了 “传输数据 / 供电的方式”，不管你插 U 盘、鼠标还是移动硬盘（不同 “实现”），只要设备符合 USB 标准，就能和电脑交互；电脑不用管 “U 盘里存的是照片还是文档”。

简单说：**接口就是 “统一的规则”，定义了 “能做什么”，屏蔽了 “具体怎么做”**。

## 二、回到 C++：`Shape`中的 “接口” 到底是什么？

C++ 没有像 Java 那样专门的`interface`关键字，而是靠**抽象基类 + 纯虚函数** 模拟 “接口”。在`Shape`的例子里：

### 1. “接口” 的具体形式：纯虚函数（约定规则）





```c++
class Shape {
public:
    // 这一行，就是Shape的“接口”！
    virtual double calculateArea() = 0; // 纯虚函数
    virtual ~Shape() = default;
};
```

这个`calculateArea()`纯虚函数，就是`Shape`定义的 **“接口规则”**：

- 规则内容：所有继承`Shape`的类，都必须实现一个名叫`calculateArea`的方法；
- 规则约束：这个方法必须返回`double`类型，无参数（你可以理解为 “插头必须是三孔的”）；
- 规则核心：只要求 “能计算面积”，完全不管 “怎么算”（比如矩形是宽 × 高，圆形是 πr²）。

### 2. “所有形状都遵循该接口”：遵守规则

继承`Shape`的子类（`Rectangle`、`Circle`、`Triangle`），必须按这个规则实现`calculateArea`—— 这就是 “遵循接口”：





```c++
// 矩形遵循接口：按规则实现calculateArea（返回double，无参数）
class Rectangle : public Shape {
private:
    double width, height;
public:
    double calculateArea() override { // 严格遵守接口规则
        return width * height; // 自己的实现逻辑，接口不管
    }
};

// 圆形遵循接口：同样按规则实现，只是逻辑不同
class Circle : public Shape {
private:
    double radius;
public:
    double calculateArea() override { // 严格遵守接口规则
        return 3.14 * radius * radius; // 自己的实现逻辑
    }
};
```

如果子类不遵守这个规则（比如不实现`calculateArea`，或把返回值改成`int`），编译器会直接报错 —— 相当于 “插头不符合插座标准，插不进去”。

### 3. “接口是稳定的”：规则不变，实现可变

“稳定” 的意思是：`Shape`的接口（`calculateArea()`的规则）一旦定义，就不会轻易修改（比如不会突然改成`int calculateArea(int a)`）。

比如你后续要新增 “三角形”，只需要按这个稳定的接口实现即可，完全不用改`Shape`本身，也不用改调用接口的代码：



```c++
// 新增三角形：遵循稳定的接口，无需修改原有代码
class Triangle : public Shape {
private:
    double base, height;
public:
    double calculateArea() override { // 还是同一个接口规则
        return 0.5 * base * height; // 新的实现逻辑
    }
};
```

## 三、接口的核心价值（为什么要搞这个？）

还是回到代码调用的场景，你就能明白接口的意义：



```c++
// 调用端：只认Shape的接口，不认具体是哪种形状
void printArea(Shape* shape) {
    // 不管传进来的是矩形、圆形还是三角形，都调用同一个接口方法
    cout << "面积：" << shape->calculateArea() << endl;
}

int main() {
    Shape* rect = new Rectangle(2, 3);
    Shape* circle = new Circle(2);
    Shape* triangle = new Triangle(3, 4);

    // 调用方式完全一样！因为都遵循同一个接口
    printArea(rect);     // 输出6
    printArea(circle);   // 输出12.56
    printArea(triangle); // 输出6

    delete rect; delete circle; delete triangle;
    return 0;
}
```

- 对调用者（`printArea`函数）来说：它只需要知道 “传进来的是 Shape 类型，有 calculateArea 方法”，不用关心具体是哪种形状 ——**解耦了 “调用逻辑” 和 “具体实现”**；
- 对扩展来说：新增任何形状，`printArea`一行代码都不用改 —— 这就是 “开闭原则” 的落地。

## 四、一句话总结：接口到底是什么？

在 C++ 的抽象基类场景中，**接口就是 “纯虚函数定义的统一规则”**：

- 它规定了 “子类必须能做什么”（比如计算面积）；
- 不限制 “子类具体怎么做”（比如矩形 / 圆形的不同算法）；
- 调用者只认这个规则，不认具体的子类 —— 这就是接口的核心作用。

------

### 总结（核心要点）

1. **接口的本质**：是 “约定 / 规则”，在 C++ 中由抽象基类的纯虚函数实现，只定义 “能做什么”，不定义 “怎么做”；
2. **遵循接口**：子类必须按接口的规则（方法名、返回值、参数）实现对应的方法；
3. **接口稳定**：规则一旦确定就不轻易改，新增功能只需扩展子类，不用修改接口本身。

简单记：接口就是 “插座标准”，子类就是 “各种电器插头”，只要插头符合标准，就能用同一个插座（调用逻辑）。