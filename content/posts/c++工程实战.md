---
title: C++工程实战
published: 2026-02-14T23:01:16+08:00
summary: "对与B站c++工程实战的学习笔记"
cover:
  image: https://bucket-qjy.oss-cn-qingdao.aliyuncs.com/picture/202602142304908.png
tags: [c++学习笔记]
categories: '现代c++'
draft: false
lang: ''
---

# c++基本语法知识

## 1.有关变量

![image-20260214230652282](https://bucket-qjy.oss-cn-qingdao.aliyuncs.com/picture/202602142306454.png)

### **变量定义语法 **

- **语法格式**
  使用 C++11 标准，变量定义格式为：`类型 变量名 {初始值};`
  示例：`int x {100};`
- **类型检查机制**
  编译器会对赋值类型进行严格检查，防止非法赋值（如将字符串赋给整型变量）。

1.当我们定义一个变量的时候，这时程序就申请了空间，如果此时我们不初始化，因为c++注重效率，他可能不会初始化为0，而是直接使用已经释放掉的内存，所以值是不确定的

2.变量的内存地址使用&获取

3.sizeof是一个运算符，基本不占用内存获取变量所占用的内存

**关于字面量后缀可以改变字面量在内存中的大小，这一个点使用auto有所体现**

### 1.变量的作用域与生命周期

   1.局部变量与全局变量：**少用全局变量**

2. 变量的生命周期

   全局变量：进入函数之前申请，main函数结束之后释放

   作用域：在不做声明的情况下，本文件都可以访问

   局部变量：变量定义开始到}结束

   作用域：当前定义的{}内部

### 2.有关常量

![image-20260214232320484](https://bucket-qjy.oss-cn-qingdao.aliyuncs.com/picture/202602142323700.png)

**关于运行时常量与编译时常量**

#### 1. 优先用编译时常量（constexpr）的场景

- 当值**可以在编译期确定**（比如固定的最大值、数学常量、配置常量等）；
- 需要用于**编译期上下文**（数组大小、模板参数、switch 的 case 值等）；
- 追求性能：编译时常量无需运行时读取内存，编译器直接替换值，效率更高。

#### 2. 只能用运行时常量（const）的场景

- 值**必须在运行时才能确定**（比如用户输入、读取文件、系统时间、硬件参数等）；
- 类的非静态成员常量（C++11 前，类内 const 成员只能运行时初始化；C++11 后 static constexpr 可编译期初始化）。

#### 3. 避坑提醒

- 不要用`const`伪装编译时常量：比如`const int a = get_value();`（`get_value()`是运行时函数），此时`a`是运行时常量，不能用于数组大小；
- C++11 及以上，优先用`constexpr`代替`const`定义编译时常量（更明确、更严格）。

#### 总结

1. **编译时常量**（constexpr/const 字面量）：值在编译期确定，无内存开销，适用于固定值、编译期上下文，性能更优；
2. **运行时常量**（const + 运行时值）：值在运行期确定，占内存，仅适用于无法提前确定值的场景；
3. 选择原则：**能编译期确定就用 constexpr，只能运行期确定才用 const**，避免用 const 误导自己和编译器。

### 3.关于auto自动推导类型



```c++
#include <iostream>
using namespace std;

int main()
{
    // 变量定义使用{初始化}
    int x{0};
    // 关于字面量有无后缀区别
    cout << sizeof(123LL) << "   " << sizeof(123) << endl;
    // 关于生命周期，内部代码块与外部无关
    {
        int x{3};
        cout << x << endl;
    }
    {
        // 关于运行时常量与编译时常量
        constexpr int a = 5;
        int arry[a]; // 这是合法的，因为a在编译期间就确定了a=5,
        const int b = 5;
        int arry1[b]; // 非法，编译期间b的值不确定
    }
    {
        // 关于auto的使用
        // 1.auto定义普通变量，注意对与auto变量，不同于普通变量使用{}或者=初始化没有区别
        auto a1{1.f};
        auto b1{12LL};
        const float temp{a1};
        auto c1 = temp;       // 使用auto去推导一个const常量赋值的时候，c1是一个普通变量
        auto const c2 = temp; // 此时c2才是const float型
    }

    return 0;
}

/*
    运行结果
    8    4
    3
*/
```





