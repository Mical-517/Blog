---
title: 面向对象程序设计2
published: 2026-02-19T22:44:04+08:00
summary: "关于继承类中作用域以及拷贝控制"
cover:
  image: https://bucket-qjy.oss-cn-qingdao.aliyuncs.com/picture/202602011340604.png
tags: [opp]
categories: '现代c++'
draft: false
lang: ''
---

### 15.6 继承中的类作用域

继承体系中每个类都有独立作用域，**派生类的作用域嵌套在其直接基类作用域内**，这是理解继承中名字查找、重载覆盖的核心前提。

#### 15.6.1 作用域嵌套与名字查找规则

当访问派生类对象的某个名字（成员 / 函数）时，编译器按以下顺序查找：

1. 派生类自身作用域 → 2. 直接基类作用域 → 3. 间接基类作用域 → 4. 全局作用域。

   

   若派生类定义了与基类

   同名的成员 / 函数

   （即使函数参数列表不同），会

   隐藏

   基类的同名实体（而非重载）。

**代码示例：基础作用域嵌套与名字隐藏**



```c++
#include <iostream>
using namespace std;

// 基类
class Base {
public:
    int num = 10;
    void print() {
        cout << "Base::num = " << num << endl;
    }
    void print(int x) { // 基类重载print
        cout << "Base::print(int) = " << x << endl;
    }
};

// 派生类
class Derived : public Base {
public:
    int num = 20; // 隐藏基类num
    void print() { // 隐藏基类所有print重载
        cout << "Derived::num = " << num << endl;
    }
};

int main() {
    Derived d;
    d.print();       // 调用Derived::print() → 输出 Derived::num = 20
    // d.print(10);  // 编译报错：Derived隐藏了Base的print(int)，找不到匹配函数
    d.Base::print(10); // 显式指定基类作用域 → 输出 Base::print(int) = 10
    cout << d.num << endl;        // 访问Derived::num → 20
    cout << d.Base::num << endl;  // 显式访问基类num → 10
    return 0;
}
```

#### 15.6.2 派生类使用 using 覆盖特定重载函数

若想让基类的重载函数在派生类中继续生效（避免被隐藏），可通过`using`声明将基类的函数名引入派生类作用域（`using`会引入该名字的**所有重载版本**，无法单独引入某一个）。

**代码示例：using 恢复基类重载函数**







```c++
#include <iostream>
using namespace std;

class Base {
public:
    void print(int x) { cout << "Base::print(int) = " << x << endl; }
    void print(double x) { cout << "Base::print(double) = " << x << endl; }
};

class Derived : public Base {
public:
    void print(string s) { cout << "Derived::print(string) = " << s << endl; }
    using Base::print; // 引入Base所有print重载，与自身print(string)形成重载集
};

int main() {
    Derived d;
    d.print(10);      // 调用Base::print(int) → Base::print(int) = 10
    d.print(3.14);    // 调用Base::print(double) → Base::print(double) = 3.14
    d.print("hello"); // 调用Derived::print(string) → Derived::print(string) = hello
    return 0;
}
```

------

### 15.7 构造函数与拷贝控制

派生类对象包含「基类子对象 + 派生类自身成员」，因此派生类的构造、拷贝、移动、析构必须处理基类子对象的对应操作。

#### 15.7.1 虚析构函数

当通过**基类指针 / 引用删除派生类对象**时，若基类析构函数非虚，会导致「仅销毁基类子对象，派生类成员未销毁」的未定义行为（内存泄漏）。

**核心规则**：被用作基类（尤其是多态场景）的类，析构函数必须声明为`virtual`。

**代码示例：虚析构的必要性**





```c++
#include <iostream>
using namespace std;

// 错误示例：基类析构非虚
class BadBase {
public:
    BadBase() { cout << "BadBase 构造" << endl; }
    ~BadBase() { cout << "BadBase 析构" << endl; } // 非虚析构
};

class BadDerived : public BadBase {
public:
    int* ptr; // 动态内存成员
    BadDerived() : ptr(new int(10)) { cout << "BadDerived 构造" << endl; }
    ~BadDerived() {
        delete ptr; // 释放内存
        cout << "BadDerived 析构" << endl;
    }
};

// 正确示例：基类析构为虚
class GoodBase {
public:
    GoodBase() { cout << "GoodBase 构造" << endl; }
    virtual ~GoodBase() { cout << "GoodBase 析构" << endl; } // 虚析构
};

class GoodDerived : public GoodBase {
public:
    int* ptr;
    GoodDerived() : ptr(new int(20)) { cout << "GoodDerived 构造" << endl; }
    ~GoodDerived() override { // override显式标记（C++11+）
        delete ptr;
        cout << "GoodDerived 析构" << endl;
    }
};

int main() {
    // 错误场景：仅销毁基类，派生类内存泄漏
    cout << "=== 错误示例 ===" << endl;
    BadBase* bad_p = new BadDerived();
    delete bad_p; // 仅输出 BadBase 析构（ptr未释放）

    // 正确场景：虚析构触发完整析构
    cout << "\n=== 正确示例 ===" << endl;
    GoodBase* good_p = new GoodDerived();
    delete good_p; // 先析构GoodDerived，再析构GoodBase
    return 0;
}
```

**输出结果**：





```
=== 错误示例 ===
BadBase 构造
BadDerived 构造
BadBase 析构

=== 正确示例 ===
GoodBase 构造
GoodDerived 构造
GoodDerived 析构
GoodBase 析构
```

#### 15.7.2 合成拷贝控制与继承（核心要点）

若未显式定义派生类的拷贝 / 移动构造、赋值运算符、析构函数，编译器会**合成默认版本**，核心规则：

1. **合成构造**：派生类合成构造会自动调用基类对应构造（默认 / 拷贝 / 移动）初始化基类子对象；
2. **合成赋值**：派生类合成赋值会先调用基类赋值，再赋值自身成员；
3. **合成析构**：先销毁派生类成员，再自动调用基类析构（无论基类析构是否为虚）；
4. **限制**：若基类无默认构造 / 拷贝控制被删除，派生类对应合成版本也会被标记为 “删除”（无法使用）。

**代码示例：合成拷贝控制的行为**



```c++
#include <iostream>
using namespace std;

class Base {
public:
    int base_val = 100;
    Base() { cout << "Base 默认构造" << endl; }
    Base(const Base& other) : base_val(other.base_val) {
        cout << "Base 拷贝构造" << endl;
    }
    Base& operator=(const Base& other) {
        base_val = other.base_val;
        cout << "Base 拷贝赋值" << endl;
        return *this;
    }
    virtual ~Base() { cout << "Base 析构" << endl; }
};

class Derived : public Base {
public:
    int der_val = 200;
    // 未显式定义拷贝控制，编译器合成
};

int main() {
    Derived d1;
    Derived d2 = d1; // 合成拷贝构造：调用Base拷贝构造 + 拷贝der_val
    d2.der_val = 300;
    Derived d3;
    d3 = d2; // 合成拷贝赋值：调用Base拷贝赋值 + 赋值der_val
    return 0;
}
```

**输出结果**：





```
Base 默认构造
Base 拷贝构造
Base 默认构造
Base 拷贝赋值
Base 析构
Base 析构
Base 析构
```

#### 15.7.3 派生类的拷贝控制成员

若需自定义派生类拷贝控制，必须**显式处理基类子对象**（否则基类子对象会用默认方式初始化 / 赋值）。

##### 15.7.3.1 自定义拷贝 / 移动构造函数

**核心规则**：派生类构造函数必须在**初始化列表**中显式调用基类的拷贝 / 移动构造（未显式调用则尝试调用基类默认构造，无默认构造则编译报错）。





```c++
#include <iostream>
using namespace std;

class Base {
public:
    string name;
    Base(const string& s) : name(s) { cout << "Base 构造: " << name << endl; }
    Base(const Base& other) : name(other.name) {
        cout << "Base 拷贝构造: " << name << endl;
    }
    Base(Base&& other) noexcept : name(move(other.name)) {
        cout << "Base 移动构造: " << name << endl;
    }
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    int age;
    // 派生类构造：初始化列表显式初始化基类
    Derived(const string& s, int a) : Base(s), age(a) {
        cout << "Derived 构造: " << age << endl;
    }
    // 自定义拷贝构造：显式调用基类拷贝构造
    Derived(const Derived& other) : Base(other), age(other.age) {
        cout << "Derived 拷贝构造: " << age << endl;
    }
    // 自定义移动构造：显式调用基类移动构造
    Derived(Derived&& other) noexcept : Base(move(other)), age(move(other.age)) {
        cout << "Derived 移动构造: " << age << endl;
    }
};

int main() {
    Derived d1("Tom", 20);
    Derived d2 = d1;    // 拷贝构造
    Derived d3 = move(d1); // 移动构造
    return 0;
}
```

**输出结果**：





```
Base 构造: Tom
Derived 构造: 20
Base 拷贝构造: Tom
Derived 拷贝构造: 20
Base 移动构造: Tom
Derived 移动构造: 20
```

##### 15.7.3.2 自定义赋值运算符

**核心规则**：赋值运算符无法在初始化列表操作，需在函数体中**先调用基类赋值**，再处理自身成员；必须加入「自赋值判断」避免逻辑错误。





```c++
#include <iostream>
using namespace std;

class Base {
public:
    int base_val = 10;
    Base& operator=(const Base& other) {
        if (this != &other) { // 自赋值判断
            base_val = other.base_val;
            cout << "Base 拷贝赋值: " << base_val << endl;
        }
        return *this;
    }
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    int der_val = 20;
    Derived& operator=(const Derived& other) {
        if (this != &other) {
            Base::operator=(other); // 先赋值基类子对象
            der_val = other.der_val; // 再赋值自身成员
            cout << "Derived 拷贝赋值: " << der_val << endl;
        }
        return *this;
    }
};

int main() {
    Derived d1, d2;
    d1.base_val = 100; d1.der_val = 200;
    d2 = d1; // 调用自定义赋值
    return 0;
}
```

**输出结果**：



```
Base 拷贝赋值: 100
Derived 拷贝赋值: 200
```

##### 15.7.3.3 自定义析构函数

**核心规则**：

1. 派生类析构只需处理自身成员，基类子对象的析构由编译器**自动调用**（析构顺序：派生类 → 基类）；
2. 若基类析构为虚函数，派生类析构自动成为虚函数，建议用`override`显式标记。





```c++
#include <iostream>
using namespace std;

class Base {
public:
    string data;
    Base(const string& s) : data(s) {}
    virtual ~Base() { cout << "Base 析构: " << data << endl; }
};

class Derived : public Base {
public:
    string msg;
    Derived(const string& s, const string& m) : Base(s), msg(m) {}
    ~Derived() override { // override显式标记
        cout << "Derived 析构: " << msg << endl;
        // 无需显式调用Base::~Base()，编译器自动执行
    }
};

int main() {
    Base* p = new Derived("base_data", "derived_msg");
    delete p; // 虚析构触发完整析构
    return 0;
}
```

**输出结果**：



```
Derived 析构: derived_msg
Base 析构: base_data
```

------

### 核心总结

1. 作用域：派生类作用域嵌套基类，同名成员隐藏基类版本，`using`可恢复基类重载；

2. 虚析构：多态基类必须声明虚析构，否则派生类对象销毁不完整；

3. 拷贝控制：

   - 合成版本自动处理基类子对象，自定义版本需显式调用基类对应操作；
   - 构造函数在初始化列表处理基类，赋值运算符在函数体处理基类；
   - 析构函数无需显式调用基类，编译器自动按「派生→基类」顺序执行。

   