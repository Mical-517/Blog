---
title: 六大开发原则
published: 2026-02-25T09:43:14+08:00
summary: "关于开发原则简介"
cover:
  image: https://bucket-qjy.oss-cn-qingdao.aliyuncs.com/picture/202602011340604.png
tags: [开发原则]
categories: '现代c++'
draft: false
lang: ''
---

## 一、开闭原则（OCP: Open-Closed Principle）

### 通俗定义

**对扩展开放，对修改关闭**：新增功能时，通过扩展现有代码（如新增子类 / 实现类）完成，而非修改已有、稳定的代码。

### 代码示例（反例→正例）

#### 反例（违反 OCP）：新增形状需修改原有计算逻辑





```c++
#include <iostream>
using namespace std;

// 形状类：新增圆形时，必须修改这个类的calculateArea方法
class Shape {
public:
    enum Type { RECTANGLE, CIRCLE };
    Type type;
    double width, height, radius;

    double calculateArea() {
        if (type == RECTANGLE) {
            return width * height;
        } else if (type == CIRCLE) { // 新增圆形：必须修改原有方法
            return 3.14 * radius * radius;
        }
        return 0;
    }
};

int main() {
    Shape rect;
    rect.type = Shape::RECTANGLE;
    rect.width = 2; rect.height = 3;
    cout << "矩形面积：" << rect.calculateArea() << endl;

    // 若要新增三角形，必须再次修改Shape::calculateArea → 违反OCP
    return 0;
}
```

#### 正例（遵循 OCP）：新增形状只需扩展，无需修改原有代码





```c++
#include <iostream>
using namespace std;

// 抽象基类（接口）：稳定，无需修改
class Shape {
public:
    virtual double calculateArea() = 0; // 纯虚函数定义统一接口
    virtual ~Shape() = default;
};

// 矩形：已有实现，无需修改
class Rectangle : public Shape {
private:
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    double calculateArea() override {
        return width * height;
    }
};

// 圆形：新增扩展，不修改任何原有代码
class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    double calculateArea() override {
        return 3.14 * radius * radius;
    }
};

// 面积计算器：高层逻辑，无需修改
class AreaCalculator {
public:
    static void printArea(Shape* shape) {
        cout << "面积：" << shape->calculateArea() << endl;
    }
};

int main() {
    Shape* rect = new Rectangle(2, 3);
    AreaCalculator::printArea(rect); // 输出：面积：6

    Shape* circle = new Circle(2);
    AreaCalculator::printArea(circle); // 输出：面积：12.56

    // 新增三角形：只需加Triangle类，无需修改Shape/AreaCalculator
    delete rect; delete circle;
    return 0;
}
```

### 核心解释

- 抽象基类`Shape`定义了稳定的接口，所有形状都遵循该接口；
- 新增任何形状（如三角形），只需继承`Shape`并实现`calculateArea`，原有代码一行都不用改；
- 这就是 “对扩展开放（新增类），对修改关闭（不碰原有代码）”。

------

## 二、单一职责原则（SRP: Single Responsibility Principle）

### 通俗定义

**一个类只负责一项职责**：避免一个类承担多个无关功能，否则修改一个功能可能影响其他功能。

### 代码示例（反例→正例）

#### 反例（违反 SRP）：订单类既计算金额，又保存到文件





```c++
#include <iostream>
#include <fstream>
using namespace std;

// 订单类：同时负责“金额计算”和“文件存储”→ 两个职责
class Order {
private:
    double price;
    int quantity;
public:
    Order(double p, int q) : price(p), quantity(q) {}

    // 职责1：计算总金额
    double calculateTotal() {
        return price * quantity;
    }

    // 职责2：保存到文件（修改文件存储逻辑时，可能影响金额计算）
    void saveToFile(const string& path) {
        ofstream file(path);
        file << "总价：" << calculateTotal() << endl;
        file.close();
    }
};
```

#### 正例（遵循 SRP）：拆分职责为独立类





```c++
#include <iostream>
#include <fstream>
using namespace std;

// 职责1：仅负责订单金额计算
class OrderCalculator {
private:
    double price;
    int quantity;
public:
    OrderCalculator(double p, int q) : price(p), quantity(q) {}
    double calculateTotal() {
        return price * quantity;
    }
};

// 职责2：仅负责订单持久化（文件存储）
class OrderPersistence {
public:
    static void saveToFile(double total, const string& path) {
        ofstream file(path);
        file << "总价：" << total << endl;
        file.close();
    }
};

int main() {
    OrderCalculator calc(100, 2);
    double total = calc.calculateTotal(); // 200

    OrderPersistence::saveToFile(total, "order.txt");
    return 0;
}
```

### 核心解释

- `OrderCalculator`只关心 “计算金额”，`OrderPersistence`只关心 “保存文件”，各自职责单一；
- 若要修改文件存储逻辑（比如改成保存到数据库），只需改`OrderPersistence`，完全不影响金额计算；
- 若要优化金额计算（比如加折扣），只需改`OrderCalculator`，不影响存储逻辑。

------

## 三、里氏替换原则（LSP: Liskov Substitution Principle）

### 通俗定义

**所有引用基类的地方，都能透明地替换成其子类对象**：子类必须完全兼容基类的行为，不能破坏基类的契约。

### 代码示例（反例→正例）

#### 反例（违反 LSP）：正方形继承矩形，破坏基类契约





```c++
#include <iostream>
using namespace std;

// 基类：矩形（契约：宽和高可独立设置）
class Rectangle {
protected:
    double width, height;
public:
    void setWidth(double w) { width = w; }
    void setHeight(double h) { height = h; }
    double getArea() { return width * height; }
};

// 子类：正方形（违反契约：宽高必须相等）
class Square : public Rectangle {
public:
    void setWidth(double w) override {
        width = w;
        height = w; // 强行同步宽高，破坏基类契约
    }
    void setHeight(double h) override {
        height = h;
        width = h;
    }
};

// 期望：传入矩形，设置宽2、高3，面积应为6 → 但传入正方形时出错
void testRectangle(Rectangle* rect) {
    rect->setWidth(2);
    rect->setHeight(3);
    cout << "面积：" << rect->getArea() << endl; // 正方形输出9，不符合预期
}

int main() {
    Rectangle rect;
    testRectangle(&rect); // 正确：6

    Square square;
    testRectangle(&square); // 错误：9 → 违反LSP
    return 0;
}
```

#### 正例（遵循 LSP）：重新设计抽象，子类兼容基类契约





```c++
#include <iostream>
using namespace std;

// 抽象基类：四边形（只定义面积接口，不定义宽高设置）
class Quadrilateral {
public:
    virtual double getArea() = 0;
    virtual ~Quadrilateral() = default;
};

// 矩形：遵循基类契约
class Rectangle : public Quadrilateral {
private:
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    double getArea() override { return width * height; }
};

// 正方形：遵循基类契约（独立实现，不破坏基类逻辑）
class Square : public Quadrilateral {
private:
    double side;
public:
    Square(double s) : side(s) {}
    double getArea() override { return side * side; }
};

// 测试：引用基类的地方，可替换为任意子类
void printArea(Quadrilateral* shape) {
    cout << "面积：" << shape->getArea() << endl;
}

int main() {
    Quadrilateral* rect = new Rectangle(2, 3);
    printArea(rect); // 正确：6

    Quadrilateral* square = new Square(3);
    printArea(square); // 正确：9

    delete rect; delete square;
    return 0;
}
```

### 核心解释

- 违反 LSP 的本质是 “子类修改了基类的核心行为”；
- 遵循 LSP 的关键：基类定义清晰的契约（接口），子类仅实现契约，不修改契约的语义；
- 上例中`Quadrilateral`只定义 “获取面积” 的契约，`Rectangle`和`Square`各自实现，替换后逻辑完全符合预期。

------

## 四、依赖倒置原则（DIP: Dependency Inversion Principle）

### 通俗定义

**高层模块不依赖低层模块，二者都依赖抽象；抽象不依赖细节，细节依赖抽象**：避免高层逻辑和底层实现紧耦合。

### 代码示例（反例→正例）

#### 反例（违反 DIP）：高层模块直接依赖低层实现





```c++
#include <iostream>
using namespace std;

// 低层模块：微信消息发送（具体实现）
class WeChatSender {
public:
    void send(string msg) {
        cout << "微信发送：" << msg << endl;
    }
};

// 高层模块：消息通知（直接依赖WeChatSender）
class Notification {
private:
    WeChatSender sender; // 紧耦合：换支付宝发送需修改此类
public:
    void notify(string msg) {
        sender.send(msg);
    }
};

int main() {
    Notification notify;
    notify.notify("你有新订单"); // 只能微信发送
    // 若要新增支付宝发送，必须修改Notification类 → 违反DIP
    return 0;
}
```

#### 正例（遵循 DIP）：高层和低层都依赖抽象接口



```c++
#include <iostream>
using namespace std;

// 抽象接口：消息发送器（高层和低层都依赖这个抽象）
class MessageSender {
public:
    virtual void send(string msg) = 0;
    virtual ~MessageSender() = default;
};

// 低层模块1：微信发送（细节依赖抽象）
class WeChatSender : public MessageSender {
public:
    void send(string msg) override {
        cout << "微信发送：" << msg << endl;
    }
};

// 低层模块2：支付宝发送（新增扩展，细节依赖抽象）
class AliPaySender : public MessageSender {
public:
    void send(string msg) override {
        cout << "支付宝发送：" << msg << endl;
    }
};

// 高层模块：消息通知（依赖抽象，不依赖具体实现）
class Notification {
private:
    MessageSender* sender; // 依赖抽象接口
public:
    // 构造注入：运行时可替换任意实现
    Notification(MessageSender* s) : sender(s) {}
    void notify(string msg) {
        sender->send(msg);
    }
};

int main() {
    // 微信通知：注入WeChatSender
    MessageSender* weChat = new WeChatSender();
    Notification notify1(weChat);
    notify1.notify("你有新订单"); // 微信发送

    // 支付宝通知：注入AliPaySender（无需修改Notification）
    MessageSender* aliPay = new AliPaySender();
    Notification notify2(aliPay);
    notify2.notify("你有新订单"); // 支付宝发送

    delete weChat; delete aliPay;
    return 0;
}
```

### 核心解释

- 抽象接口`MessageSender`是 “中间层”，高层`Notification`只依赖它，低层`WeChatSender/AliPaySender`也实现它；
- 新增任何发送方式（如短信），只需新增`MessageSender`的子类，高层代码完全不用改；
- 这解决了 “高层依赖低层” 的耦合问题，是实现开闭原则的核心基础。

------

## 五、接口隔离原则（ISP: Interface Segregation Principle）

### 通俗定义

**客户端不应依赖它不需要的接口**：拆分大而全的接口为多个小而专的接口，避免客户端被迫依赖用不到的方法。

### 代码示例（反例→正例）

#### 反例（违反 ISP）：大接口包含无关方法，客户端被迫依赖





```c++
#include <iostream>
using namespace std;

// 大接口：包含打印、扫描、传真 → 即使客户端只需要打印，也得依赖全部
class MultiFunctionPrinter {
public:
    virtual void print() = 0;
    virtual void scan() = 0;
    virtual void fax() = 0;
};

// 客户端1：普通打印机（只需要打印，却被迫实现scan/fax）
class SimplePrinter : public MultiFunctionPrinter {
public:
    void print() override { cout << "打印文档" << endl; }
    void scan() override { /* 用不到，空实现 → 冗余 */ }
    void fax() override { /* 用不到，空实现 → 冗余 */ }
};
```

#### 正例（遵循 ISP）：拆分接口为小而专的独立接口





```c++
#include <iostream>
using namespace std;

// 小接口1：仅打印
class Printable {
public:
    virtual void print() = 0;
    virtual ~Printable() = default;
};

// 小接口2：仅扫描
class Scannable {
public:
    virtual void scan() = 0;
    virtual ~Scannable() = default;
};

// 小接口3：仅传真
class Faxable {
public:
    virtual void fax() = 0;
    virtual ~Faxable() = default;
};

// 客户端1：普通打印机 → 只依赖Printable
class SimplePrinter : public Printable {
public:
    void print() override { cout << "打印文档" << endl; }
};

// 客户端2：多功能打印机 → 组合多个小接口
class MultiFunctionPrinter : public Printable, public Scannable, public Faxable {
public:
    void print() override { cout << "打印文档" << endl; }
    void scan() override { cout << "扫描文档" << endl; }
    void fax() override { cout << "传真文档" << endl; }
};

int main() {
    Printable* simple = new SimplePrinter();
    simple->print(); // 只用到打印，无冗余依赖

    MultiFunctionPrinter* mfp = new MultiFunctionPrinter();
    mfp->print();
    mfp->scan();

    delete simple; delete mfp;
    return 0;
}
```

### 核心解释

- 拆分后的小接口只包含单一功能，客户端按需实现 / 依赖，避免 “空实现冗余方法”；
- 进阶技巧：C++ 中可用**前置声明**替代头文件包含，进一步减少依赖（如`class Printable;`而非`#include "Printable.h"`，仅用指针 / 引用时）；
- 核心目标：最小化客户端的依赖范围，降低耦合，减少编译依赖。

------

## 六、迪米特法则（LoD: Law of Demeter / 最少知识原则）

### 通俗定义

**一个对象应对其他对象保持最少了解**：只和直接 “朋友” 通信（如成员变量、方法参数），不通过 “朋友” 找 “朋友”。

### 代码示例（反例→正例）

#### 反例（违反 LoD）：通过多层对象调用，增加依赖





```c++
#include <iostream>
#include <string>
using namespace std;

// 商品类
class Product {
private:
    string name;
public:
    Product(string n) : name(n) {}
    string getName() { return name; }
};

// 购物车类
class ShoppingCart {
private:
    Product* product;
public:
    ShoppingCart(Product* p) : product(p) {}
    Product* getProduct() { return product; } // 暴露内部对象
};

// 订单类（违反LoD：通过购物车找商品，了解了不必要的细节）
class Order {
public:
    void printOrder(ShoppingCart* cart) {
        // 错误：cart是朋友，但product是cart的朋友 → 跨层调用
        string productName = cart->getProduct()->getName();
        cout << "订单商品：" << productName << endl;
    }
};
```

#### 正例（遵循 LoD）：只和直接朋友通信，封装内部细节





```c++
#include <iostream>
#include <string>
using namespace std;

// 商品类
class Product {
private:
    string name;
public:
    Product(string n) : name(n) {}
    string getName() { return name; }
};

// 购物车类（封装细节，不暴露内部对象）
class ShoppingCart {
private:
    Product* product;
public:
    ShoppingCart(Product* p) : product(p) {}
    // 提供直接的方法，而非暴露内部对象
    string getProductName() {
        return product->getName(); // 内部处理，对外隐藏
    }
};

// 订单类（遵循LoD：只和cart通信，不接触product）
class Order {
public:
    void printOrder(ShoppingCart* cart) {
        // 正确：只调用直接朋友cart的方法
        string productName = cart->getProductName();
        cout << "订单商品：" << productName << endl;
    }
};

int main() {
    Product* apple = new Product("苹果");
    ShoppingCart* cart = new ShoppingCart(apple);
    Order order;
    order.printOrder(cart); // 输出：订单商品：苹果

    delete apple; delete cart;
    return 0;
}
```

### 核心解释

- 迪米特法则的核心是 “封装”：对象只暴露必要的接口，隐藏内部依赖；
- 上例中`ShoppingCart`不再暴露`Product*`，而是提供`getProductName()`，`Order`无需知道`ShoppingCart`内部有`Product`对象；
- 好处：若后续`ShoppingCart`修改了`Product`的存储方式（比如用数组），`Order`的代码完全不用改，降低了耦合风险。

------

### 总结（六大设计原则核心要点）

1. **开闭原则（OCP）**：核心目标是 “扩展不修改”，依赖抽象接口实现；
2. **单一职责（SRP）**：一个类只做一件事，是解耦的基础；
3. **里氏替换（LSP）**：子类必须兼容基类，保证接口替换的安全性；
4. **依赖倒置（DIP）**：高层依赖抽象，低层实现抽象，解决耦合核心；
5. **接口隔离（ISP）**：接口要小而专，避免客户端依赖无用接口；
6. **迪米特法则（LoD）**：最少知识，只和直接朋友通信，隐藏内部细节。

所有原则的最终目标都是：**降低耦合、提高内聚、增强代码的可扩展和可维护性**，